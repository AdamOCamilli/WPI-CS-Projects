#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <pthread.h>
#include <limits.h>
#include <unistd.h>
#include <time.h>

#define NUM_NODES 40
#define NUM_NOISEMAKERS 2

#define DWELL_DUR 10
#define DWELL_PROB 90
#define NOISE_DWELL_PROB 75

#define TALK_WINDOW_TIME 10
#define TRANSMISSION_TIME 0.5
#define NOISE_PROB 65
#define TALK_PROB 90

typedef enum Device_Type {
  node,
  noisemaker,
  null
} Device_Type;

typedef enum Channel {
  ONE = 1,
  SIX = 6, 
  ELEVEN = 11  
} Channel;

typedef struct coord_pair {
  int x;
  int y;
} coord_pair;

/* Represents a message that can be sent or received by devices.
 * Can be used to determine application id of device who sent it by
 * subtracting message_id from sum.
 */
typedef struct message {
  char* content;
  unsigned short id; // random short generated by calling node
} message;

/* Doubly linked list for keeping track of seen messages and
 * accompanying necessary helper methods.
 */
typedef struct dll_node {
  message msg;
  struct dll_node *prev, *next;
} dll_node;

void append(dll_node *head, message m) {
  dll_node *ptr = head;
  dll_node *new  = (dll_node *)malloc(sizeof(struct dll_node));
  new->msg = m;
  new->prev = NULL;
  new->next = NULL;

  if (head == NULL) {
    head = new;
    return;
  } else { 
    while(ptr->next != NULL) // get to tail
      ptr = ptr->next;
    ptr->next = new;
    new->prev = ptr;
  }
}

// Find message in doubly linked list using its id
dll_node* find(dll_node *head, message m) {
  dll_node *ptr = (dll_node *)malloc(sizeof(dll_node));
  ptr = head;
  while (ptr != NULL) {
    if ((ptr->msg).id == m.id)
      return ptr; // dll_node with matching id found
    ptr = ptr->next;
  } return NULL;
} 

/* Info for a given device, in particular:
 *
 * Its type: Whether it is a node, noisemaker, or null (i.e. no thread is matched to this struct yet)
 * Its thread id given by pthread_self() (for debugging)
 * Its id within the context of the program (when it was created: 0, 1, 2, etc)
 * What channel it is on, for listening and sending
 * What messages it has received (head of a doubly linked list of message_ids)
 * Its coordinates (which never change)
 * Which nodes are within a 10x10 square centered on this node's coordinates
 * Its own log file
*/
typedef struct device_info {
  Device_Type type;
  int thread_id;
  int id;
  Channel channel;
  dll_node received;
  int rebroadcasted; // how many messages this node has rebroadcasted
  coord_pair coords;
  int overlapped[99]; // 99 is max number of possible overlapping nodes in 10x10 square
  FILE *log;
} device_info;

// Arbitrary values for seed and message content
const unsigned int seed = 4;           // arbitrary seed value
char* sample_messages[6] = {"Hello!", "Hey!", "Bonjour!", "Salut!", "¡Hola!", "¿Qué onda?"}; 

// Global locks and condition variables
pthread_mutex_t ch1_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t ch6_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t ch11_mutex = PTHREAD_MUTEX_INITIALIZER;

int ch1_noise;
pthread_cond_t ch1_noise_cond = PTHREAD_COND_INITIALIZER;
int ch6_noise;
pthread_cond_t ch6_noise_cond =  PTHREAD_COND_INITIALIZER;
int ch11_noise;
pthread_cond_t ch11_noise_cond =  PTHREAD_COND_INITIALIZER;
int ch1_in_use;
pthread_cond_t ch1_in_use_cond =  PTHREAD_COND_INITIALIZER;
int ch6_in_use;
pthread_cond_t ch6_in_use_cond =  PTHREAD_COND_INITIALIZER;
int ch11_in_use;
pthread_cond_t ch11_in_use_cond =  PTHREAD_COND_INITIALIZER;

// Data structures to keep track of threads
pthread_t nodes[NUM_NODES+NUM_NOISEMAKERS];
device_info node_info[NUM_NODES + NUM_NOISEMAKERS];

/* Returns a random unsigned short */
unsigned short rand_short();

/* Function pointer to each node's routine */
void *node_func(device_info *d);

/* Sends a message to all nodes overlapped with d */
void broadcast(device_info *d, message msg, int rebroadcast);

/* Sends a message from one node to another, returns 0 on failure and 1 on success*/
int send(device_info *from, device_info *to, message msg, int is_rebroadcast); 

/* Return random enum Channel value */
Channel rand_channel();

/* Write to d what nodes d is overlapped with */
void find_overlapping(device_info *d);

/* Return how many nodes d overlaps with */
int how_many_overlaps(device_info *d);

/* Return whether two nodes have overlapping coordinates */
int overlapping(device_info *d1, device_info *d2);

int unique_coords(int current_num_nodes, device_info d);

int main() {

  srand(seed);

  int rc, i;

  // Create all nodes, and match up and initialize their info structs
  for (i = 0; i < NUM_NODES; i++) {
    node_info[i].type = node;
    node_info[i].id = i;
    // Set x and y to be unique [0,99] values
    (node_info[i].coords).x = rand() % 100; // set x
    (node_info[i].coords).y = rand() % 100; // set y
    node_info[i].channel = rand_channel();
    node_info[i].rebroadcasted = 0;
    // Create log file with name "node[num].txt"
    char log_name[4 + (1 + i/10) + 4]; // "node" + number of  digits + ".txt"
    sprintf(log_name, "%s%d.txt", "node", i);
    node_info[i].log = fopen(log_name, "w");
    if (node_info[i].log == NULL) {
      printf("Error creating log file!\n");
      exit(1);
    }

    // Create thread for this node
    if ( (rc = pthread_create(&nodes[i], NULL, (void*)node_func, &node_info[i])) )
      printf("Thread %d could not be created.\n", i);
    // Write to log that node has successfully been created
    fprintf(node_info[i].log, "Node %d created on channel %d at (%d , %d)\n",node_info[i].id, node_info[i].channel, node_info[i].coords.x, node_info[i].coords.y);
  } printf("All nodes successfully created!\n");

  // Create noisemakers and match up and initialize their info structs
  for (; i < NUM_NODES+NUM_NOISEMAKERS; i++) {
    node_info[i].type = noisemaker;
    node_info[i].id = i;
    // Set x and y to be unique [0,99] values
    (node_info[i].coords).x = rand() % 100; // set x
    (node_info[i].coords).y = rand() % 100; // set y
    node_info[i].channel = rand_channel();
    char log_name[10 + (1 + (i-NUM_NODES) / 10) + 4]; // "noisemaker" + number of digits + ".txt"
    sprintf(log_name, "%s%d.txt", "noisemaker", i-NUM_NODES);
    node_info[i].log = fopen(log_name, "w");
    if (node_info[i].log == NULL) {
      printf("Error creating log file!\n");
      exit(1);
    }

    // Create thread for this noisemaker
    if ( (rc = pthread_create(&nodes[i], NULL, (void*)node_func, &node_info[i])) )
      printf("Thread %d could not be created.\n", i);
    // Write to log that node has successfully been created
    fprintf(node_info[i].log, "Noisemaker %d created on channel %d.\n",node_info[i].id, node_info[i].channel);
  } printf("All noisemakers successfully created!\n");
  
  i = 0;
  for(; i < NUM_NODES + NUM_NOISEMAKERS; i++) {
    pthread_join(nodes[i], NULL);
  }

  // Clean up and exit
  return 0;
}

void *node_func(device_info *d) {
  
  int i;
  for(i = 0; i < 2; i++) {

    if (rand() % 101 > NOISE_DWELL_PROB) { d->channel = rand_channel(); }
    
    if (d->type == noisemaker) {
      if (rand() % 101 < NOISE_PROB) {
	switch (d->channel) {
	case ONE:
	  pthread_mutex_lock(&ch1_mutex);
	  ch1_noise = 1;
	  break;
	case SIX:
	  pthread_mutex_lock(&ch6_mutex);
	  ch6_noise = 1;
	  break;
	case ELEVEN:
	  pthread_mutex_lock(&ch11_mutex);
	  ch11_noise = 1;
	  break;
	}

	printf("Noise on channel %d\n",d->channel);
	fprintf(d->log, "Activated at (%d, %d) on channel %d.\n", d->coords.x, d->coords.y, d->channel);
	fflush(stdout);
	sleep(1);

	switch (d->channel) {
	case ONE:
	  ch1_noise = 0;
	  pthread_cond_signal(&ch1_noise_cond);
	  pthread_mutex_unlock(&ch1_mutex);
	  break;
	case SIX:
	  ch6_noise = 0;
	  pthread_cond_signal(&ch6_noise_cond);
	  pthread_mutex_unlock(&ch6_mutex);pthread_cond_signal(&ch6_noise_cond);
	  break;
	case ELEVEN:
	  ch11_noise = 0;
	  pthread_cond_signal(&ch11_noise_cond);
	  pthread_mutex_unlock(&ch11_mutex);	  
	  break;
	} fprintf(d->log, "Deactivated at (%d, %d) on channel %d\n", d->coords.x, d->coords.y, d->channel);
      }
    } else {
    
      find_overlapping(d); // First get all nodes we are overlapped with
      int r = rand() % 6;
      message m = {.content = sample_messages[r], .id = rand_short()};
      // Chance to change channel
      if (rand() % 101 > DWELL_PROB) { d->channel = rand_channel(); }
      
      if (rand() % 101 < TALK_PROB) {
	switch(d->channel) {
	case ONE:
	  pthread_mutex_lock(&ch1_mutex);
	  while (ch1_in_use)
	    pthread_cond_wait(&ch1_in_use_cond, &ch1_mutex);
	  while (ch1_noise)
	    pthread_cond_wait(&ch1_noise_cond, &ch1_mutex);
	  ch1_in_use = 1;
	  break;
	case SIX:
	  pthread_mutex_lock(&ch6_mutex);
	  while (ch6_in_use)
	    pthread_cond_wait(&ch6_in_use_cond, &ch6_mutex);
	  while (ch1_noise)
	    pthread_cond_wait(&ch6_noise_cond, &ch6_mutex);
	  ch6_in_use = 1;
	  break;
	case ELEVEN:
	  pthread_mutex_lock(&ch11_mutex);
	  while (ch11_in_use)
	    pthread_cond_wait(&ch11_in_use_cond, &ch11_mutex);
	  while (ch1_noise)
	    pthread_cond_wait(&ch11_noise_cond, &ch11_mutex);
	  ch11_in_use = 1;
	  break;
	}

	broadcast(d,m,0);
	sleep(TRANSMISSION_TIME);

	switch(d->channel) {
	case ONE:
	  if (ch1_in_use)
	    pthread_cond_signal(&ch1_in_use_cond);
	  ch1_in_use = 0;
	  pthread_mutex_unlock(&ch1_mutex);
	  break;
	case SIX:
	  if (ch6_in_use)
	    pthread_cond_signal(&ch6_in_use_cond);
	  ch6_in_use = 0;
	  pthread_mutex_unlock(&ch6_mutex);
	  break;
	case ELEVEN:
	  if (ch11_in_use)
	    pthread_cond_signal(&ch11_in_use_cond);
	  ch11_in_use = 0;
	  pthread_mutex_unlock(&ch11_mutex);
	  break;
	}
      } printf("Node %d went through iteration\n",d->id);
    }
  }
}

void broadcast(device_info *d, message msg, int rebroadcast) {  
  int i;
  for (i = 0; i < how_many_overlaps(d); i++) {
    send(d, &node_info[d->overlapped[i]], msg, rebroadcast);
  }

  if (rebroadcast == 0) {
    // Now deal with rebroadcasting received messsages (if any)
    // Get to most recent unrebroadcasted message and rebroadcast it along with any after it
    int b = d->rebroadcasted;
    dll_node *ptr = malloc(sizeof(ptr));
    ptr = d->received.next;
    while (ptr != NULL) {
      broadcast(d,ptr->msg,1);
      ptr = ptr->next;
    }
  }
}

// Broadcasts a random message to all overlapping neighbors
int send(device_info *from, device_info *to, message msg, int is_rebroadcast) {

  char *str = malloc(sizeof("rebroadcast"));
  if (is_rebroadcast) { str = "rebroadcast"; }
  else { str = "send"; }
  
  // First check that from and to overlap, and log and return 0 if not
  if (!overlapping(from,to)) {
    fprintf(from->log,"Tried and failed to %s message to non-overlapped node %d\n",str,to->id);
    return 0;
  }

  // Now check they are on the same channel, same procedure as above
  if (from->channel != to->channel) {
    fprintf(from->log,"On channel %d, tried and failed to %s message to node %d on channel %d\n",from->channel, str, to->id, to->channel);
    return 0;
  }
  
  // Alright, clear to try sending message
  if (find(&(to->received), msg) == NULL) { // if to hasn't seen this msg before
    append(&(to->received), msg);
  } else {
    fprintf(from->log,"Now %sing message with id %d to node %d, but it has already seen this message.\n", str, msg.id, to->id);
    return 0;
  }
  // If sent successfully, log and return 1
  if (find(&(to->received), msg) != NULL) {
    fprintf(from->log, "Now %sing message \"%s\" to node %d over channel %d\n",str,  msg.content, to->id, from->channel);
    fprintf(to->log, "(%d , %d) : Received message \"%s\" from node %d over channel %d\n",to->coords.x, to->coords.y, msg.content, from->id, from->channel);
    return 1;
  } else {
    fprintf(from->log,"Somehow sent an invalid message %d to node %d over channel %d\n", msg.id, to->id, from->channel);
    return 0;
  }
}
      
unsigned short rand_short() {
  return (unsigned short) rand() % (SHRT_MAX + 1);
}

Channel rand_channel() {
  int r = rand() % 3;
  if (r == 1) return SIX;
  if (r == 2) return ELEVEN;
  else return ONE;
}

void find_overlapping(device_info *d) {
  // Node finds out and writes to log which nodes d is overlapped with
  int i = 0;
  int j = 0;
  for (; i < NUM_NODES; i++) {
    if (overlapping(d,&node_info[i])) {
      d->overlapped[j++] = node_info[i].id;
    }
  }
  fprintf(d->log,"Node %d has %d nodes overlapping it.\n",d->id,j);
}

int how_many_overlaps(device_info *d) {
  int i = 0;
  int j = 0;
  for (; i < NUM_NODES; i++) {
    if (overlapping(d,&node_info[i])) {
      j++;
    }
  } return j;
}

/* Returns whether d1 is overlapped with d2. Ignore noisemakers since they don't care about overlaps.
 * 
 * Specifically, whether d1's x and y coordinates are within +- 5 of
 * d2's respective x and y coordinates.
 */
int overlapping(device_info *d1, device_info *d2) {
  if (d1->type == noisemaker || d2->type == noisemaker)
    return 0;
  
  if (d1->id == d2->id) return 0; // nodes can't overlap themselves
  if ( (d1->coords.x >= d2->coords.x - 5) && (d1->coords.x <= d2->coords.x + 5) )
    return ( (d1->coords.y >= d2->coords.y - 5) && (d1->coords.y <= d2->coords.y + 5) );	
  return 0;
}

int unique_coords(int current_num_nodes, device_info d) {
  int i;
  for (i = 0; i < current_num_nodes; i++) {
    if ( (node_info[i].coords).x == (d.coords).x )
      if ( (node_info[i].coords).y == (d.coords).y )
	return 0;
  } return 1;
}
