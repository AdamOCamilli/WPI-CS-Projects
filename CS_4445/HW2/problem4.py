from mrjob.job import MRJob
import numpy as np

#-------------------------------------------------------------------------
'''
    Problem 4: 
    In this problem, you will use mapreduce framework to implement matrix multipication. 
    You could test the correctness of your code by typing `nosetests test4.py` in the terminal.
'''

#--------------------------
class MatMul(MRJob):
#--------------------------
    ''' 
        Given a matrix A and a matrix B, compute the product A*B = C
    '''

    #----------------------
    @staticmethod
    def parse_line(line):
        '''
            parse one line of text from the data file.
            Input:
                    line: one line of text of a data record
            return: 
                    matrix_name: 'A' or 'B' 
                    i: row index, an integer (note, the index starts from 1) 
                    j: column index (note, the index starts from 1) 
                    v: the value of the entry; 
                    nr: number of rows in the matrix C
                    nc: number of columns in the matrix C
        '''
        #########################################
        ## INSERT YOUR CODE HERE

        values = line.split(",");
        matrix_name = str(values[0])
        i,j = map(int, (values[1], values[2]))
        v = float(values[3])
        nr, nc = map(int, (values[4], values[5]))
        
        #########################################
        return matrix_name, i,j,v, nr, nc

    #----------------------
    def mapper(self, in_key, in_value):
        ''' 
            mapper function, which process a key-value pair in the data and generate intermediate key-value pair(s)
            Input:
                    in_key: the key of a data record (in this example, can be ignored)
                    in_value: the value of a data record, (in this example, it is a line of text string in the data file, check 'matrix.csv' for example)
            Yield: 
                    (out_key, out_value) :intermediate key-value pair(s). You need to design the format and meaning of the key-value pairs. These intermediate key-value pairs will be feed to reducers, after grouping all the values with a same key into a value list.
        '''
        
        # parse one line of text data
        matrix_name, i,j,v, nr, nc = self.parse_line(in_value)

        #########################################
        ## INSERT YOUR CODE HERE

        # generate output key-value pairs 
        new_matrix_name = "C"
        new_matrix = np.zeros((nr,nc))
        for ni,nj in np.ndindex(new_matrix.shape):
          yield (new_matrix_name,int(ni)+1,int(nj)+1),(matrix_name,i,j,v)
          


        # yield v, in_value
        # print(in_key, in_value)
        # if (matrix_name == "A"):
        #   for i in range(0,nc):
        #     yield (matrix_name,i,j), in_key  
        #     yield v, in_value
        # elif (matrix_name == "B"):
        #   for j in range(0,nr): 
        #     yield (matrix_name,i,j), in_key
        #     yield v, in_value

        #########################################

    #----------------------
    def reducer(self, in_key, in_values):
        ''' 
            reducer function, which processes a key and value list and produces output key-value pair(s)
            Input:
                    in_key: an intermediate key from the mapper
                    in_values: a list (generator) of values , which contains all the intermediate values with the same key (in_key) generated by all mappers
            Yield: 
                    (out_key, out_value) : output key-value pair(s). 
        '''
        #########################################
        ## INSERT YOUR CODE HERE

        i = in_key[1]
        j = in_key[2]

        C = 0.
        for V in in_values:
          print("AV", V)
          if (V[0] == "A"):
            print("V",V)
            for W in in_values:
              print("AW", W)
              if (W[0] == "B"):
                print("W", W)
                if (V[2] == W[1]):
                  C += V[3] * W[3]
          elif (V[0] == "B"):
            print("BV", V)
            for W in in_values:
              print("BW", W)
              if (W[0] == "A"):
                if (V[1] == W[2]):
                  C += V[3] * W[3]
        
        print("C", C)
            
        # for value in in_values:
        #   for n in range(1,4):
        #     print(n,value[0], value[1], value[2], value[3])
        #     if (value[0] == "A" and value[1] == i and value[2] == n):
        #         A = value[3]
        #         print("A", A)
        #     elif (value[0] == "B" and value[2] == j and value[1] == n):
        #         B = value[3]
        #         print("B", B)
        #     if (A >= 0 and B >= 0):
        #         C += A*B
        #         print("C", C)
        #         A = -1.
        #         B = -1.

        # print()
        yield in_key, C

        #########################################

