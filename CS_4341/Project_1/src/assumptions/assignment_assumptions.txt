Our assumptions for how Gomoku is played for the purposes of this project are the following:

1) The game sequence is as follows (from assignment description):

    1. A random selection method is used to determine which player will use the white stones 
        and which player will use the black stones. In what follows, the player who gets to 
        use the white stones is called P1 and the player who gets to use the black stones 
        is called P2.
        
    2. P1 gets to play first.
    
    3. After player1 has made its first move, player2 is given the chance to change the color
        of the stone on the board to black. This is done to limit the advantages of playing first.

    4. After that, players 1 and 2 take turns making moves until the game ends with one player winning 
        or a tie. There is a 10 second time limit for a player to make its move.
        
    5. Game board is 15x15
        
2) The program must utilize the Minimax algorithm with alpha-beta pruning, with our choice of utility function.

3) The program must only produce valid moves, and must be able to read and process opponents' moves.

4) A game between our program and an opponent will be conducted by a third party program called Referee.

    1. Referee maintains four text files:
        1) move_file
        2) <Our group name>.go
        3) <Opponent group name>.go
        4) end_game 
        
    2. Referee creates end_game if and only if one of the following conditions are met:
        1) A player gets five-in-a-row (Wins)
        2) A player makes an invalid moves (Loses)
        3) A player takes longer than 10 sec to make a move (Loses)
        4) A player makes a move out-of-order (Loses)
        5) Board is full (Tie)
    
    2. Game is played in practice via the following process:
        1) Both programs check if end_game or their .go file exists
        2) Randomly selected player (P1) writes its first move to P1.go after checking for end game (P1CHECK -> P1GOES)
        3) Ref reads both .go file, checks if an end condition is met, if yes creates end_game, otherwise makes other .go file (REFCHECK)
        3) P2 checks if end_game exists (P2CHECK)
        4) Non-selected player (P2) decides whether or not to change stone color
        5) P2 reads move_file, decides on a move, then writes it to its .go file (P2GOES)
        5) REFCHECK
        6) P1CHECK
        7) P1GOES
        8) REFCHECK
        9) P2CHECK
        10) P2GOES
        11) REFCHECK
        12) P1CHECK
        13) P1GOES
        ...
        ...
        N)   REFCHECK creates end_game
        N+1) P1 and P2 read end_game to learn result
    
    3. Referee code is provided at <https://github.com/samogden/WPI.CS4341>
 
	4. Moves are written to move_file in the following format: 
		"<Group Name> <Column> <Row>"
		where columns are <A-O> and rows are <1-15>, and move is on one line.
		Example: "Group1 E 5"

5)
		
	   

