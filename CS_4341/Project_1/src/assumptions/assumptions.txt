"""
Our assumptions for how Gomoku is played for the purposes of this project are the following:

1) The game sequence is as follows (from assignment description):

    1. A random selection method is used to determine which player will use the white stones 
        and which player will use the black stones. In what follows, the player who gets to 
        use the white stones is called P1 and the player who gets to use the black stones 
        is called P2.
        
    2. P1 gets to play first.
    
    3. After player1 has made its first move, player2 is given the chance to change the color
        of the stone on the board to black. This is done to limit the advantages of playing first.

    4. After that, players 1 and 2 take turns making moves until the game ends with one player winning 
        or a tie. There is a 10 second time limit for a player to make its move.
        
    5. 
        
2) The program must utilize the Minimax algorithm with alpha-beta pruning, with our choice of utility function.

3) The program must only produce valid moves, and must be able to read and process opponents' moves.

4) A game between our program and an opponent will be conducted by a third party program called Referee.

    1. Referee maintains four text files:
        1) move_file
        2) <Our group name>.go
        3) <Opponent group name>.go
        4) end_game 
        
    2. Referee creates end_game if and only if one of the following conditions are met:
        1) A player gets five-in-a-row (Wins)
        2) A player makes an invalid moves (Loses)
        3) A player takes longer than 10 sec to make a move (Loses)
        4) A player makes a move out-of-order (Loses)
        5) Board is full (Tie)
    
    2. Game is played via the following process:
        1) Both programs check if end_game exists (it does not at start)
        2) Randomly selected player (P1) writes its first move into move_file
        3) Ref checks if an end condition is met, if yes creates end_game (REFCHECK)
        3) Non-selected player (P2) decides whether or not to change stone color
        4) P2 checks if end_game exists (P2CHECK) 
        5) P2 reads move_file, decides on a move, then overwrites move_file with their move (P2GOES)
        5) REFCHECK
        6) P1 checks if end_game exists (P1CHECK) 
        7) P1 reads move_file, decides on a move and overwrites move_file (P1GOES)
        8) REFCHECK
        9) P2CHECK
        10) P2GOES
        11) REFCHECK
        12) P1CHECK
        13) P1GOES
        ....
        REFCHECK creates end_game
        P1 and P2 read end_game to learn result
    
    3. Referee

"""